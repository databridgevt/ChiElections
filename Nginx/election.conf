server {
    # SSL (HTTPS) connections happen by default on 443
    listen 443 http2 default_server;
    listen [::]:443 default_server;

    # Serve files from this directory
    root /var/www/chicago;

    # The "main" html file is called index.html
    index index.html;

    # Domain for our server
    server_name something.com www.something.com;

    location / {
        try_files $uri $uri/ =404;
    }

    # Reverse proxy /api route to our node backend
    # TODO rate limiting
    location /api {
        proxy_pass http://nest:3000;    # Nginx templates? I wish there was a way to 
                                        # distinguish the docker network 
                                        # from localhost at build time
        proxy_http_version  1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # Enable client-side caching, if our website hasn't 
    # changed, there's no reason to send the same copy
    location ~* \.(jpg|jpeg|png|gif|ico)$ {
        expires 30d;
    }

    location ~* \.(css|js)$ {
        expires 7d;
    }

    # SSL/TLS Encryption
    #ssl on;
    #ssl_certificate / etc/letsencrypt/live/something.com/fullchain.pem;
    #ssl_certificate_key /etc/letsencrypt/live/something.com/privkey.pem;
    #ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    #ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS:!3DES';
    #add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";


    # Enable Compression for Responses
    # Warning: This is security risk for sensitive data
    #          The static html is not sensitive. But we shouldn't use this
    #          for user data.
    # gzip on; I think it's already on in the default conf
}

# People expect to connect to a site on Port 80
# this server block redirects inbound 80s to the above server
server {
    listen 0.0.0.0:80;
    server_name something.com www.something.com;

    # Send the client a 301 (Moved Permanently)
    # And redirect to the https url
    #rewrite ^ https://$host$request_uri? permanent;

    # Serve at port 80 until we get certificates

    # The "main" html file is called index.html
    index index.html;

    limit_req_zone $binary_remote_addr zone=chicagolim:10m rate=10r/s;

    # Reverse proxy /api route to our node backend
    # TODO rate limiting
    location /api {
        limit_req zone=chicagolim burst=10 nodelay;
        proxy_pass http://nest:3000;    # Nginx templates? I wish there was a way to 
                                        # distinguish the docker network 
                                        # from localhost at build time
        proxy_http_version  1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}